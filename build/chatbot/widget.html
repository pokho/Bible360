<!-- Support Chatbot Widget -->
<div class="sc-widget-container" id="sc-widget-container">
  <!-- Chat Button -->
  <button class="sc-chat-button" id="sc-chat-button" aria-label="Open chat">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
    </svg>
  </button>

  <!-- Chat Window -->
  <div class="sc-chat-window" id="sc-chat-window">
    <!-- Header -->
    <div class="sc-chat-header">
      <!-- Drag handle for moving chatbot -->
      <div class="sc-drag-handle" id="sc-drag-handle" title="Drag to move"></div>
      <div class="sc-chat-avatar">
        <svg viewBox="0 0 24 24" fill="white" width="24" height="24">
              <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
             </svg>
      </div>
      <div class="sc-chat-info">
        <h3>Bible360</h3>
        <p>Support Assistant</p>
      </div>
      <button class="sc-close-button" id="sc-close-button" aria-label="Close chat">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
          <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
        </svg>
      </button>
    </div>

    <!-- Messages -->
    <div class="sc-messages" id="sc-messages">
      <div class="sc-message bot">
        Hi! I&#039;m Bible360 assistant.
      </div>
    </div>

    <!-- Escalation Notice (shown when needed) -->
    <div class="sc-escalation-notice" id="sc-escalation-notice" style="display: none;">
      Connecting you to a human agent...
    </div>

    <!-- Input Area -->
    <div class="sc-input-area">
      <input
        type="text"
        class="sc-input-field"
        id="sc-input-field"
        placeholder="Type your message..."
        autocomplete="off"
      >
      <button class="sc-send-button" id="sc-send-button" aria-label="Send message">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
          <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
        </svg>
      </button>
    </div>
  </div>
</div>
<style>/* Support Chatbot Widget Styles */
:root {
  --sc-primary-color: #3b82f6;
  --sc-text-color: #1f2937;
  --sc-bg-color: #ffffff;
  --sc-font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.sc-widget-container {
  position: fixed;
  bottom: 20px; right: 20px;
  z-index: 9999;
  font-family: var(--sc-font);
}

.sc-chat-button {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: var(--sc-primary-color);
  border: none;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.2s, box-shadow 0.2s;
}

.sc-chat-button:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
}

.sc-chat-button svg {
  width: 28px;
  height: 28px;
  fill: white;
}

.sc-chat-window {
  position: absolute;
  bottom: 80px;
  right: 0;
  width: 380px;
  height: 600px;
  max-height: calc(100vh - 120px);
  background: var(--sc-bg-color);
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  opacity: 0;
  transform: scale(0.9);
  pointer-events: none;
  transition: opacity 0.3s, transform 0.3s;
}

.sc-chat-window.sc-open {
  opacity: 1;
  transform: scale(1);
  pointer-events: all;
}

.sc-chat-header {
  background: var(--sc-primary-color);
  color: white;
  padding: 16px 20px;
  display: flex;
  align-items: center;
  gap: 12px;
}

.sc-chat-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.sc-chat-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.sc-chat-info h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.sc-chat-info p {
  margin: 2px 0 0;
  font-size: 12px;
  opacity: 0.9;
}

.sc-close-button {
  margin-left: auto;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  padding: 4px;
  opacity: 0.8;
  transition: opacity 0.2s;
}

.sc-close-button:hover {
  opacity: 1;
}

.sc-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sc-message {
  max-width: 80%;
  padding: 12px 16px;
  border-radius: 12px;
  line-height: 1.5;
  animation: sc-fadeIn 0.3s ease-out;
}

@keyframes sc-fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.sc-message.bot {
  background: #f3f4f6;
  color: var(--sc-text-color);
  align-self: flex-start;
  border-bottom-left-radius: 4px;
}

.sc-message.user {
  background: var(--sc-primary-color);
  color: white;
  align-self: flex-end;
  border-bottom-right-radius: 4px;
}

.sc-message.typing {
  background: #f3f4f6;
  padding: 8px 16px;
}

.sc-typing-indicator {
  display: flex;
  gap: 4px;
}

.sc-typing-indicator span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #9ca3af;
  animation: sc-bounce 1.4s infinite ease-in-out both;
}

.sc-typing-indicator span:nth-child(1) {
  animation-delay: -0.32s;
}

.sc-typing-indicator span:nth-child(2) {
  animation-delay: -0.16s;
}

@keyframes sc-bounce {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  40% {
    transform: scale(1);
    opacity: 1;
  }
}

.sc-input-area {
  padding: 16px;
  border-top: 1px solid #e5e7eb;
  display: flex;
  gap: 8px;
}

.sc-input-field {
  flex: 1;
  padding: 12px 16px;
  border: 1px solid #e5e7eb;
  border-radius: 24px;
  font-family: inherit;
  font-size: 14px;
  outline: none;
  transition: border-color 0.2s;
}

.sc-input-field:focus {
  border-color: var(--sc-primary-color);
}

.sc-send-button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--sc-primary-color);
  border: none;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: opacity 0.2s;
}

.sc-send-button:hover {
  opacity: 0.9;
}

.sc-send-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.sc-escalation-notice {
  padding: 12px 16px;
  background: #fffbeb;
  border-top: 1px solid #fcd34d;
  font-size: 12px;
  color: #92400e;
  text-align: center;
}

@media (max-width: 480px) {
  .sc-chat-window {
    width: calc(100vw - 40px);
    height: calc(100vh - 120px);
  }
}</style><script>
// Support Chatbot - Client-Side Mode (works on static hosting)
(function() {
  'use strict';

  const config = {
    instanceName: 'bible360',
    brandName: 'Bible360',
    provider: 'openrouter',
    model: 'meta-llama/llama-3-8b-instruct:free',
    apiKey: undefined,
    knowledgeBase: {"chunks":[],"metadata":{"version":"1.0.0","exportedAt":"2026-02-14T10:22:06.772Z","totalChunks":0,"categories":[],"compressed":false}},
    escalationEnabled: false,
    oksomeUrl: '',
    escalationThreshold: 50,
    mode: 'support',
    autoOpen: true,
    draggable: false,
    constrainToViewport: true,
    rememberPosition: true,
    dragHandleStyle: config.draggable?.handleStyle || 'bar',
  };

  
        // Draggable disabled - no drag handle or CSS
      
  
// Client-side RAG (Retrieval-Augmented Generation)
function searchKnowledge(query) {
  if (!config.knowledgeBase || !config.knowledgeBase.chunks) {
    return { chunks: [], context: '', confidence: 0 };
  }

  const queryWords = query.toLowerCase().split(/\s+/);
  const scoredChunks = config.knowledgeBase.chunks.map(chunk => {
    const content = chunk.content.toLowerCase();
    let score = 0;

    // Exact phrase match
    if (content.includes(query.toLowerCase())) {
      score += 50;
    }

    // Word matches
    for (const word of queryWords) {
      if (word.length > 2 && content.includes(word)) {
        score += 10;
      }
    }

    // Tag matches
    if (chunk.metadata.tags) {
      for (const tag of chunk.metadata.tags) {
        if (queryWords.some(qw => tag.toLowerCase().includes(qw))) {
          score += 15;
        }
      }
    }

    // Priority boost
    if (chunk.metadata.priority) {
      score += chunk.metadata.priority * 5;
    }

    return { chunk, score };
  });

  // Sort by score and filter relevant results
  scoredChunks.sort((a, b) => b.score - a.score);
  const relevantChunks = scoredChunks
    .filter(s => s.score > 0)
    .slice(0, 5)
    .map(s => s.chunk);

  // Build context from relevant chunks
  const context = relevantChunks
    .map(c => `[Source: ${c.metadata.source}] ${c.content}`)
    .join('\n\n');

  const confidence = scoredChunks.length > 0 ? Math.min(100, scoredChunks[0].score) : 0;

  return { chunks: relevantChunks, context, confidence };
}

  
// Client-side frustration detection
function detectFrustration(message) {
  const msgLower = message.toLowerCase().trim();
  const msgUpper = message.toUpperCase();
  const msgRaw = message;

  // Escalation keywords
  const escalationKeywords = [
    'human', 'agent', 'person', 'representative', 'support',
    'useless', 'terrible', 'horrible', 'awful', 'stupid',
    'manager', 'supervisor', ' escalate', 'talk to someone'
  ];

  // Check for escalation keywords
  const hasKeyword = escalationKeywords.some(kw => msgLower.includes(kw));

  // ALL CAPS detection (at least 3 words, mostly uppercase)
  const words = msgRaw.split(/\s+/).filter(w => w.length > 0);
  const allCapsWords = words.filter(w => w === w.toUpperCase() && w.length > 1);
  const isAllCaps = words.length >= 3 && allCapsWords.length / words.length > 0.7;

  // Excessive punctuation detection
  const punctuationMatch = msgRaw.match(/[!?]/g);
  const exclamationCount = punctuationMatch ? punctuationMatch.length : 0;
  const hasExcessivePunctuation = exclamationCount >= 3;

  // Repeated characters (e.g., "hellooooo" or "!!!!")
  const repeatedChars = /(.)\1{4,}/.test(msgRaw);

  // Short, angry messages
  const isShortAngry = words.length <= 3 && (
    msgLower.includes('!!!') ||
    msgLower.includes('??') ||
    (msgRaw === msgUpper && msgRaw !== msgLower)
  );

  return {
    shouldEscalate: hasKeyword || isAllCaps || hasExcessivePunctuation || repeatedChars || isShortAngry,
    reason: hasKeyword ? 'escalation_keyword' :
            isAllCaps ? 'all_caps' :
            hasExcessivePunctuation ? 'excessive_punctuation' :
            repeatedChars ? 'repeated_chars' :
            isShortAngry ? 'short_angry' :
            'none',
    confidence: hasKeyword ? 90 :
                 isAllCaps ? 80 :
                 hasExcessivePunctuation ? 70 :
                 repeatedChars ? 60 :
                 isShortAngry ? 75 :
                 0
  };
}

  
// Free models fetched from OpenRouter API (cached locally)
let freeModels = [];
let currentModelIndex = 0;
let modelsFetchFailed = false;

// Fetch free models from OpenRouter API
async function fetchFreeModels() {
  try {
    const response = await fetch('https://openrouter.ai/api/v1/models');
    if (!response.ok) {
      throw new Error('Failed to fetch models');
    }
    const data = await response.json();
    // Filter free models (prompt price is 0 or 0.0)
    freeModels = data.data
      .filter(m => m.pricing?.prompt === '0' || m.pricing?.prompt === '0.0')
      .map(m => m.id)
      .sort(); // Sort alphabetically for consistent ordering
    console.log('%câœ“ Loaded ' + freeModels.length + ' free models from OpenRouter', 'color: #10b981');
  } catch (error) {
    console.warn('Failed to fetch free models, using fallback list:', error);
    modelsFetchFailed = true;
    // Fallback list of known free models
    freeModels = [
      'arcee-ai/trinity-large-preview:free',
      'google/gemma-3-12b-it:free',
      'google/gemma-3-27b-it:free',
      'google/gemma-3-4b-it:free',
      'mistralai/mistral-small-3.1-24b-instruct:free',
      'stepfun/step-3.5-flash:free',
      'deepseek/deepseek-r1-0528:free',
      'nvidia/nemotron-3-nano-30b-a3b:free',
    ];
  }
}

// Get next available model
function getNextModel() {
  if (freeModels.length === 0) {
    return config.model || 'arcee-ai/trinity-large-preview:free';
  }
  const model = freeModels[currentModelIndex % freeModels.length];
  currentModelIndex++;
  return model;
}

// Reset model index for new conversation
function resetModelIndex() {
  currentModelIndex = 0;
}

// Direct OpenRouter API call with SSE streaming and fallback
async function sendMessageWithStreaming(message, context, apiKey) {
  const provider = config.provider || 'openrouter';
  // Use configured model, or start with first free model
  let model = config.model || null;

  // If no model specified, we'll use free models
  if (!model) {
    if (freeModels.length === 0 && !modelsFetchFailed) {
      await fetchFreeModels();
    }
    model = getNextModel();
    console.log('%cðŸ”„ Using free model: ' + model, 'color: #3b82f6');
  }

  let apiUrl = '';
  let headers = {
    'Content-Type': 'application/json',
    'HTTP-Referer': window.location.href,
  };

  // Configure based on provider
  if (provider === 'openrouter') {
    apiUrl = 'https://openrouter.ai/api/v1/chat/completions';
    headers['Authorization'] = `Bearer ${apiKey}`;
  } else if (provider === 'anthropic') {
    apiUrl = 'https://api.anthropic.com/v1/messages';
    headers['x-api-key'] = apiKey;
    headers['anthropic-version'] = '2023-06-01';
  } else if (provider === 'openai') {
    apiUrl = 'https://api.openai.com/v1/chat/completions';
    headers['Authorization'] = `Bearer ${apiKey}`;
  }

  // Build messages array
  const systemMessage = context ?
    `You are a helpful support assistant. Use the following knowledge base to answer questions:\n\n${context}\n\nIf the knowledge base doesn't contain relevant information, say so politely and offer to connect with a human agent.` :
    'You are a helpful support assistant.';

  const messages = provider === 'anthropic' ? [
    { role: 'user', content: message }
  ] : [
    { role: 'system', content: systemMessage },
    { role: 'user', content: message }
  ];

  // Request body
  const body = provider === 'anthropic' ? {
    model: model,
    system: systemMessage,
    messages: messages,
    max_tokens: 4096,
    stream: true
  } : {
    model: model,
    messages: messages,
    stream: true
  };

  // Try with current model, fallback to next free model on error
  let lastError = null;
  let maxRetries = freeModels.length > 0 ? Math.min(freeModels.length, 5) : 1;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    if (!config.model) {
      model = getNextModel();
      body.model = model;
      console.log('%cðŸ”„ Attempt ' + (attempt + 1) + '/' + maxRetries + ' with model: ' + model, 'color: #f59e0b');
    }

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(body)
      });

      if (!response.ok) {
        const errorText = await response.text();
        // If using free models and this is not the last attempt, try next model
        if (!config.model && attempt < maxRetries - 1) {
          console.warn('%câš ï¸ Model ' + model + ' failed, trying next free model...', 'color: #f59e0b');
          continue;
        }
        throw new Error(`API error (${response.status}): ${errorText}`);
      }

      // Success! Break out of retry loop
      console.log('%câœ… Model ' + model + ' responded successfully', 'color: #10b981');
      break;
    } catch (err) {
      lastError = err;
      // If using free models and this is not the last attempt, try next model
      if (!config.model && attempt < maxRetries - 1) {
        console.warn('%câš ï¸ Request failed with ' + model + ', trying next free model...', 'color: #f59e0b');
        continue;
      }
      throw err;
    }
  }

  // If we exhausted all retries without a configured model
  if (lastError && !config.model && freeModels.length > 0) {
    throw new Error('All free models failed. Please provide your own API key for better reliability.');
  }

  // Parse SSE stream
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let fullResponse = '';

  return {
    reader,
    decoder,
    buffer,
    fullResponse,
    parseStream: async function(onChunk, onComplete) {
        while (true) {
          const { done, value } = await this.reader.read();
          if (done) break;

          this.buffer += this.decoder.decode(value, { stream: true });

          // SSE format: "data: {...}\n\n"
          const lines = this.buffer.split('\n\n');
          this.buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6).trim();

              if (data === '[DONE]') continue;

              try {
                let json;
                if (provider === 'openrouter') {
                  json = JSON.parse(data);
                  if (json.choices?.[0]?.delta?.content) {
                    const token = json.choices[0].delta.content;
                    this.fullResponse += token;
                    onChunk(token);
                  }
                } else if (provider === 'anthropic') {
                  json = JSON.parse(data);
                  if (json.type === 'content_block_delta' && json.delta?.text) {
                    const token = json.delta.text;
                    this.fullResponse += token;
                    onChunk(token);
                  }
                } else if (provider === 'openai') {
                  json = JSON.parse(data);
                  if (json.choices?.[0]?.delta?.content) {
                    const token = json.choices[0].delta.content;
                    this.fullResponse += token;
                    onChunk(token);
                  }
                }
              } catch (e) {
                // Skip invalid JSON
                console.warn('Failed to parse SSE data:', data);
              }
            }
          }
        }

        if (onComplete) onComplete(this.fullResponse);
      }
    };
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
}

// Get or prompt for API key
async function getApiKey() {
  // Check environment variable (build-time)
  if (config.apiKey) {
    return config.apiKey;
  }

  // Check localStorage (runtime)
  const storedKey = localStorage.getItem('chatbot_api_key');
  if (storedKey) {
    return storedKey;
  }

  // Prompt user for API key
  const key = prompt(
    'Enter your ' + config.provider.toUpperCase() + ' API key:\n\n' +
    'Your key will be stored locally in your browser for future use.'
  );

  if (key && key.trim().length > 0) {
    localStorage.setItem('chatbot_api_key', key.trim());
    return key.trim();
  }

  throw new Error('API key is required for client-side chatbot');
}


  // DOM Elements
  const container = document.getElementById('sc-widget-container');
  const chatButton = document.getElementById('sc-chat-button');
  const chatWindow = document.getElementById('sc-chat-window');
  const closeButton = document.getElementById('sc-close-button');
  const messagesContainer = document.getElementById('sc-messages');
  const inputField = document.getElementById('sc-input-field');
  const sendButton = document.getElementById('sc-send-button');
  const escalationNotice = document.getElementById('sc-escalation-notice');

  let isOpen = false;
  let conversationHistory = [];
  let apiKeyCache = null;

  // Toggle chat window
  async function toggleChat() {
    isOpen = !isOpen;
    chatWindow.classList.toggle('sc-open', isOpen);
    if (isOpen) {
      inputField.focus();
      // Fetch and log free models when chatbot opens (if not already fetched)
      if (freeModels.length === 0 && !modelsFetchFailed && !config.model) {
        await fetchFreeModels();
      }
      console.log('%cðŸ“± Chatbot opened', 'color: #3b82f6; font-weight: bold');
      if (!config.model) {
        console.log('%cFree models available on OpenRouter (' + freeModels.length + ' total):', 'color: #6b7280; font-weight: bold');
        freeModels.slice(0, 5).forEach((m, i) => console.log('  ' + (i + 1) + '. ' + m));
        if (freeModels.length > 5) {
          console.log('  ... and ' + (freeModels.length - 5) + ' more');
        }
        console.log('%câœ¨ Chatbot will automatically try free models if one fails.', 'color: #10b981; font-style: italic');
      }
    }
  }

  // Add message to chat
  function addMessage(content, isUser = false) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'sc-message ' + (isUser ? 'user' : 'bot');
    messageDiv.textContent = content;
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    conversationHistory.push({
      role: isUser ? 'user' : 'assistant',
      content: content,
      timestamp: new Date().toISOString(),
    });
  }

  // Show typing indicator
  function showTyping() {
    const typingDiv = document.createElement('div');
    typingDiv.className = 'sc-message typing';
    typingDiv.id = 'sc-typing';
    typingDiv.innerHTML = '<div class="sc-typing-indicator"><span></span><span></span><span></span></div>';
    messagesContainer.appendChild(typingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  // Hide typing indicator
  function hideTyping() {
    const typing = document.getElementById('sc-typing');
    if (typing) {
      typing.remove();
    }
  }

  // Drag functionality for chatbot widget
  function initDrag() {
    if (!config.draggable?.enabled) return;

    const dragHandle = document.getElementById('sc-drag-handle');
    if (!dragHandle) return;

    // Mouse events
    dragHandle.addEventListener('mousedown', startDrag);

    // Touch events
    dragHandle.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      if (!touch) return;
      startDrag({ clientX: touch.clientX, clientY: touch.clientY });
    }, { passive: false });

    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      if (!touch) return;
      drag({ clientX: touch.clientX, clientY: touch.clientY });
    }, { passive: false });

    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDragTouch);

    // Restore saved position on load
    if (config.draggable?.rememberPosition && savedPosition.x !== null) {
      widgetContainer.style.left = savedPosition.x + 'px';
      widgetContainer.style.top = savedPosition.y + 'px';
    }
  }

  function startDrag(e) {
    if (!config.draggable?.enabled) return;
    isDragging = true;
    widgetContainer.classList.add('dragging');

    const rect = widgetContainer.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;

    // Save initial position for potential restore
    const currentX = parseFloat(widgetContainer.style.left) || 0;
    const currentY = parseFloat(widgetContainer.style.top) || 0;
    savedPosition = { x: currentX.toString(), y: currentY.toString() };
  }

  function drag(e) {
    if (!isDragging) return;

    e.preventDefault();

    const x = e.clientX - dragOffset.x;
    const y = e.clientY - dragOffset.y;

    // Constrain to viewport
    const maxX = window.innerWidth - 400;
    const maxY = window.innerHeight - 550;

    widgetContainer.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
    widgetContainer.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
    widgetContainer.style.right = 'auto';
    widgetContainer.style.bottom = 'auto';

    // Save position
    savedPosition = { x: widgetContainer.style.left, y: widgetContainer.style.top };

    // Store in localStorage
    try {
      localStorage.setItem('chatbot-position', JSON.stringify(savedPosition));
    } catch (e) {
      console.warn('Could not save position:', e);
    }
  }

  function endDrag() {
    if (!isDragging) return;
    isDragging = false;
    widgetContainer.classList.remove('dragging');
  }

  function endDragTouch() {
    endDrag();
  }

  // Send message to AI
  async function sendMessage(message) {
    if (!message.trim()) return;

    // Add user message
    addMessage(message, true);
    inputField.value = '';
    sendButton.disabled = true;

    // Check for frustration
    const frustration = detectFrustration(message);
    if (frustration.shouldEscalate && config.escalationEnabled) {
      showTyping();

      setTimeout(() => {
        hideTyping();
        escalationNotice.style.display = 'block';
        setTimeout(() => {
          escalationNotice.style.display = 'none';
          addMessage('I understand you need assistance. Let me connect you with a human agent who can better help you.', false);
          if (config.oksomeUrl) {
            window.open(config.oksomeUrl, '_blank');
          }
        }, 1500);
      }, 500);

      sendButton.disabled = false;
      inputField.focus();
      return;
    }

    // Search knowledge base
    const kb = searchKnowledge(message);
    showTyping();

    // Create streaming message div
    const messageDiv = document.createElement('div');
    messageDiv.className = 'sc-message bot';
    messagesContainer.appendChild(messageDiv);

    try {
      // Get API key (cache it)
      if (!apiKeyCache) {
        apiKeyCache = await getApiKey();
      }

      // Send message with streaming
      const stream = await sendMessageWithStreaming(message, kb.context, apiKeyCache);

      hideTyping();

      await stream.parseStream(
        (token) => {
          messageDiv.textContent += token;
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        },
        (fullResponse) => {
          conversationHistory.push({
            role: 'assistant',
            content: fullResponse,
            timestamp: new Date().toISOString(),
          });
        }
      );

    } catch (error) {
      hideTyping();
      messageDiv.textContent = 'I apologize, I\'m having trouble connecting. Please check your API key or try again later.';
      console.error('Chatbot error:', error);
    } finally {
      sendButton.disabled = false;
      inputField.focus();
    }
  }

  // Event listeners
  chatButton.addEventListener('click', toggleChat);
  closeButton.addEventListener('click', toggleChat);

  sendButton.addEventListener('click', () => {
    sendMessage(inputField.value);
  });

  inputField.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage(inputField.value);
    }
  });

  // Keyboard shortcut (Ctrl/Cmd + K)
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
      e.preventDefault();
      toggleChat();
    }
  });

  // Initialize
  console.log('%cðŸ¤– Support chatbot initialized (client-side mode)', 'color: #10b981; font-weight: bold');
  console.log('%cProvider:', 'color: #6b7280', config.provider);
  console.log('%cModel:', 'color: #6b7280', config.model || '(auto-selecting from free models)');
  console.log('%cKnowledge chunks:', 'color: #6b7280', config.knowledgeBase?.metadata?.totalChunks || 0);
  console.log('%cAuto-open:', 'color: #6b7280', config.autoOpen ? 'enabled' : 'disabled');

  // Fetch free models on initialization if no model is configured
  if (!config.model) {
    fetchFreeModels().then(() => {
      if (freeModels.length > 0) {
        console.log('%câœ“ Fetched ' + freeModels.length + ' free models for automatic fallback', 'color: #10b981');
      }
    }).catch(err => {
      console.warn('Failed to fetch free models:', err);
    });
  }

  // Initialize drag functionality
  initDrag();

  // Auto-open chatbot on page load if configured
  if (config.autoOpen) {
    // Wait for DOM to be fully loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
          if (!isOpen) {
            toggleChat();
          }
        }, 500);
      });
    } else {
      // DOM is already loaded
      setTimeout(() => {
        if (!isOpen) {
          toggleChat();
        }
      }, 500);
    }
  }
})();
</script>